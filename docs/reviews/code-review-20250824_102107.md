# WebSocket Server Code Review

**File**: `packages/server/src/websocket/server.ts`  
**Review Date**: August 24, 2025  
**Reviewer**: Claude Code Quality Analyzer

## Executive Summary

The WebSocketServer class is a well-structured core component handling real-time communication between web clients and agents. While functionally sound, there are several opportunities for refactoring to improve maintainability, reduce complexity, and enhance code reusability.

## Critical Issues

### 1. Method Complexity Overload
- **`handleAuth`** method (lines 78-149): 71 lines, excessive branching logic
- **`setupWebHandlers`** method (lines 151-203): 52 lines with multiple responsibilities
- **`setupAgentHandlers`** method (lines 205-274): 69 lines handling diverse event types

### 2. Code Duplication Patterns
Multiple similar forwarding patterns exist across agent and web handlers:
```typescript
// Pattern 1: Direct socket iteration
this.io.sockets.sockets.forEach((webSocket) => {
  const webClient = this.clients.get(webSocket.id);
  if (webClient && webClient.type === 'web') {
    webSocket.emit('permission:request', request);
  }
});

// Pattern 2: Room-based broadcasting  
this.io.to(RoomManager.getWebRoom()).emit('session:status', data);
```

### 3. Magic Numbers and Constants
- Authentication timeout: `10000` (line 71)
- Session timeout: `300000` (lines 319, 338)
- Heartbeat intervals: `60000`, `30000` (lines 487, 492)
- Stale connection threshold: `60000` (line 487)

## Refactoring Suggestions

### 1. Extract Authentication Logic
**Before:**
```typescript
private handleAuth(socket: Socket, data: ConnectionAuth) {
  // 71 lines of authentication logic
}
```

**After:**
```typescript
private handleAuth(socket: Socket, data: ConnectionAuth) {
  try {
    this.validateAuthData(data, socket);
    this.registerClient(socket, data);
    this.setupClientHandlers(socket, data.clientType);
    this.sendAuthenticationSuccess(socket, data);
    this.broadcastConnectionStatus();
  } catch (error) {
    this.handleAuthError(socket, error);
  }
}

private validateAuthData(data: ConnectionAuth, socket: Socket) {
  if (!data.clientType || !['web', 'agent'].includes(data.clientType)) {
    throw new AuthenticationError('INVALID_CLIENT_TYPE', 'Client type must be "web" or "agent"');
  }
}
```

### 2. Create Message Broadcasting Service
Extract the repeated forwarding logic into a dedicated service:

```typescript
class MessageBroadcaster {
  constructor(private io: SocketIOServer, private clients: Map<string, ClientInfo>) {}
  
  broadcastToClientType(clientType: 'web' | 'agent', event: string, data: any) {
    this.io.sockets.sockets.forEach((socket) => {
      const client = this.clients.get(socket.id);
      if (client && client.type === clientType) {
        socket.emit(event, data);
      }
    });
  }
  
  broadcastToRoom(roomName: string, event: string, data: any) {
    this.io.to(roomName).emit(event, data);
  }
}
```

### 3. Extract Constants Configuration
Create a configuration object for all timing values:

```typescript
const WEBSOCKET_CONFIG = {
  TIMEOUTS: {
    AUTH: 10000,        // 10 seconds
    SESSION: 300000,    // 5 minutes
    STALE_CONNECTION: 60000, // 1 minute
  },
  INTERVALS: {
    HEARTBEAT: 30000,   // 30 seconds
    PING: 25000,        // 25 seconds
  },
  SOCKET: {
    PING_TIMEOUT: 60000,
    PING_INTERVAL: 25000,
  }
} as const;
```

### 4. Command Processing Pipeline
The `handleExecuteCommand` method can be refactored into a pipeline pattern:

```typescript
class CommandProcessor {
  private readonly pipeline = [
    this.mergeApiOptions.bind(this),
    this.createSessionForCommand.bind(this),
    this.buildAgentCommand.bind(this),
    this.forwardCommandToAgents.bind(this),
  ];

  async process(socket: Socket, data: ExecuteCommand) {
    try {
      let context = { socket, data, apiOptions: null, session: null, command: null };
      
      for (const step of this.pipeline) {
        context = await step(context);
      }
    } catch (error) {
      this.handleCommandError(socket, data, error);
    }
  }
}
```

### 5. Event Handler Factory
Reduce setup method complexity with a factory pattern:

```typescript
class EventHandlerFactory {
  static createWebHandlers(server: WebSocketServer) {
    return {
      [SOCKET_EVENTS.EXECUTE_COMMAND]: server.handleExecuteCommand.bind(server),
      [SOCKET_EVENTS.JOIN_PROJECT]: server.handleJoinProject.bind(server),
      [SOCKET_EVENTS.LEAVE_PROJECT]: server.handleLeaveProject.bind(server),
      'permission:response': server.handlePermissionResponse.bind(server),
      // ... other handlers
    };
  }

  static createAgentHandlers(server: WebSocketServer) {
    return {
      [SOCKET_EVENTS.COMMAND_RESPONSE]: server.handleCommandResponse.bind(server),
      [SOCKET_EVENTS.AGENT_STATUS]: server.handleAgentStatus.bind(server),
      // ... other handlers
    };
  }
}
```

## Complexity Analysis

### Functions Exceeding Complexity Thresholds

1. **`handleAuth`** - 71 lines, 6+ decision points
2. **`setupWebHandlers`** - 52 lines, multiple responsibilities
3. **`setupAgentHandlers`** - 69 lines, multiple responsibilities
4. **`handleExecuteCommand`** - 28 lines but high coupling

### Cyclomatic Complexity Assessment
- Most methods have manageable complexity
- Exception: Authentication flow has excessive branching
- Recommendation: Extract validation and setup logic

## Reusability Opportunities

### 1. Generic Client Broadcasting
The forwarding logic appears 6+ times and could be abstracted:

```typescript
private forwardToClientType(
  clientType: 'web' | 'agent',
  event: string,
  data: any,
  filter?: (client: ClientInfo) => boolean
) {
  this.clients.forEach((client, socketId) => {
    if (client.type === clientType && (!filter || filter(client))) {
      client.socket.emit(event, data);
    }
  });
}
```

### 2. Session Event Handler Pattern
Session management events follow similar patterns and could use a generic handler:

```typescript
private createSessionEventHandler(
  eventName: string,
  targetRoom: string,
  logMessage: (data: any) => string
) {
  return (data: any) => {
    console.log(logMessage(data));
    this.io.to(targetRoom).emit(eventName, data);
  };
}
```

### 3. Timeout Management Utility
Authentication and heartbeat timeouts could use a common utility:

```typescript
class TimeoutManager {
  private timeouts = new Map<string, NodeJS.Timeout>();
  
  set(id: string, callback: () => void, delay: number) {
    this.clear(id);
    this.timeouts.set(id, setTimeout(callback, delay));
  }
  
  clear(id: string) {
    const timeout = this.timeouts.get(id);
    if (timeout) {
      clearTimeout(timeout);
      this.timeouts.delete(id);
    }
  }
}
```

## Architecture Improvements

### 1. Separation of Concerns
Consider splitting the WebSocketServer into:
- **ConnectionManager**: Handle auth, disconnect, heartbeat
- **MessageRouter**: Route messages between client types
- **SessionCoordinator**: Manage session lifecycle
- **EventDispatcher**: Handle event registration and dispatch

### 2. Error Handling Standardization
Create a consistent error handling strategy:

```typescript
class WebSocketError extends Error {
  constructor(
    public code: string,
    message: string,
    public socketId?: string,
    public sessionId?: string
  ) {
    super(message);
  }
}

private standardErrorHandler(socket: Socket, error: WebSocketError) {
  console.error(`[${error.code}] ${error.message}`, {
    socketId: socket.id,
    sessionId: error.sessionId
  });
  
  socket.emit(SOCKET_EVENTS.ERROR, MessageFactory.createMessage('error', {
    error: { code: error.code, message: error.message },
    sessionId: error.sessionId
  }));
}
```

## Priority Recommendations

### High Priority (Critical for Maintainability)
1. **Extract authentication logic** - Split `handleAuth` into smaller functions
2. **Create constants configuration** - Replace magic numbers with named constants
3. **Implement message broadcasting service** - Eliminate code duplication

### Medium Priority (Enhance Readability)
4. **Refactor event handler setup** - Use factory pattern for cleaner registration
5. **Standardize error handling** - Create consistent error response patterns

### Low Priority (Nice to Have)
6. **Command processing pipeline** - More advanced architectural pattern
7. **Full architectural separation** - Longer-term refactoring goal

## Code Quality Assessment

**Current State**: Well-structured but shows signs of feature growth
**Maintainability**: Good foundation, needs refactoring for long-term health
**Testability**: Methods are too large; smaller functions would improve testability
**Performance**: No significant performance issues identified

## Conclusion

The WebSocketServer demonstrates solid engineering practices but has reached a complexity threshold where refactoring would significantly improve maintainability. The primary focus should be on extracting reusable utilities and breaking down large methods into focused, single-responsibility functions.

The suggested refactors prioritize practical improvements that provide immediate value without requiring major architectural changes, making them ideal candidates for incremental improvement during regular development cycles.